# ğŸš€ WeaveãŒä½¿ãˆã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªç’°å¢ƒ

## æ¦‚è¦
ComputerUseç’°å¢ƒã§ã¯ã€å¤šæ§˜ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨ãƒ„ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ã§ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€EpisodicRAGã‚’ã¯ã˜ã‚ã¨ã™ã‚‹é«˜åº¦ãªã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ãŒå¯èƒ½ã«ãªã£ã¦ã„ã¾ã™ã€‚

## ä¸»è¦è¨€èªï¼ˆç¢ºèªæ¸ˆã¿ï¼‰

| è¨€èª | ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | ç‰¹å¾´ |
|------|-----------|------|
| **Python** | 3.12.3 | NumPy, Pandas, BeautifulSoupç­‰ã®ä¸»è¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå®Œå‚™ |
| **Node.js/JavaScript** | v18.19.1 | npm 9.2.0ã€Reactç­‰ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åˆ©ç”¨å¯èƒ½ |
| **TypeScript** | 5.9.2 | tsx/ts-nodeã§ç›´æ¥å®Ÿè¡Œå¯èƒ½ |
| **Java** | OpenJDK 21 | æœ€æ–°ã®LTSç‰ˆ |
| **C/C++** | gcc 13.3.0 | C++20å¯¾å¿œã€ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°å¯èƒ½ |
| **Bash** | 5.2+ | ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã€ã‚·ã‚¹ãƒ†ãƒ ç®¡ç† |
| **Perl** | 5.38+ | ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†ã®å®šç•ª |

## ç‰¹ç­†ã™ã¹ããƒ‘ãƒƒã‚±ãƒ¼ã‚¸/ãƒ„ãƒ¼ãƒ«

### Pythonç³»
- **æ©Ÿæ¢°å­¦ç¿’**: TensorFlow, scikit-learnï¼ˆè¦ç¢ºèªï¼‰
- **ãƒ‡ãƒ¼ã‚¿å‡¦ç†**: Pandas (2.3.2), NumPy (2.3.2)
- **Webè§£æ**: BeautifulSoup4 (4.13.5), camelot-py (1.0.9) - PDFè¡¨è§£æ

### Node.jsç³»
- **Officeæ“ä½œ**: 
  - docx (9.5.1) - Wordæ–‡æ›¸ã®ç”Ÿæˆãƒ»ç·¨é›†
  - pptxgenjs (4.0.1) - PowerPointãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ
  - pdf-lib (1.17.1) - PDFæ“ä½œ
- **UI/ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: 
  - React (19.1.1) - æœ€æ–°ç‰ˆ
  - react-dom (19.1.1)
  - react-icons (5.5.0)
- **ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«**: 
  - TypeScript (5.9.2)
  - tsx (4.20.5) - TypeScriptå®Ÿè¡Œç’°å¢ƒ
  - ts-node (10.9.2)
- **å›³è¡¨ãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: 
  - @mermaid-js/mermaid-cli (11.9.0) - å›³è¡¨ç”Ÿæˆ
  - markdown-pdf (11.0.0)
  - marked (16.2.1)
- **ç”»åƒå‡¦ç†**: 
  - sharp (0.34.3) - é«˜é€Ÿç”»åƒå‡¦ç†

### ã‚·ã‚¹ãƒ†ãƒ ãƒ„ãƒ¼ãƒ«
- **Make**: GNU Make - ãƒ“ãƒ«ãƒ‰è‡ªå‹•åŒ–
- **Git**: ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ï¼ˆè¦ç¢ºèªï¼‰
- **pip**: Python ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç®¡ç† (24.0)
- **npm**: Node.js ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç®¡ç† (9.2.0)

## æ´»ç”¨ä¾‹

### Python: EpisodicRAGã®è§£æ
```python
import pandas as pd
import json
import numpy as np

# Loopè¨˜éŒ²ã®çµ±è¨ˆè§£æ
loops = pd.read_csv('/mnt/knowledge/EpisodicRAG/index.csv')
summary = loops.groupby('category').agg({'size': 'sum', 'count': 'count'})

# ãƒ™ã‚¯ãƒˆãƒ«æ¼”ç®—ã«ã‚ˆã‚‹é¡ä¼¼åº¦è¨ˆç®—
embeddings = np.load('/mnt/knowledge/EpisodicRAG/vectors.npy')
similarity = np.dot(embeddings, embeddings.T)
```

### TypeScript: å‹å®‰å…¨ãªLoopç®¡ç†
```typescript
interface EpisodicMemory {
    id: number;
    timestamp: Date;
    title: string;
    content: string;
    embeddings?: number[];
    metadata?: {
        category: string;
        tags: string[];
        references: number[];
    };
}

class LoopManager {
    private memories: Map<number, EpisodicMemory>;
    
    constructor() {
        this.memories = new Map();
    }
    
    addMemory(memory: EpisodicMemory): void {
        this.memories.set(memory.id, memory);
    }
    
    getLatest(n: number = 5): EpisodicMemory[] {
        return Array.from(this.memories.values())
            .sort((a, b) => b.id - a.id)
            .slice(0, n);
    }
}
```

### Bash: è‡ªå‹•åŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
```bash
#!/bin/bash
# EpisodicRAGç®¡ç†ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

# æœ€æ–°ã®Loopè¨˜éŒ²ã‚’å–å¾—
get_latest_loops() {
    ls /mnt/knowledge/EpisodicRAG/Loops/Loop*.txt | sort -V | tail -5
}

# Loopè¨˜éŒ²ã®çµ±è¨ˆ
analyze_loops() {
    echo "=== Loopè¨˜éŒ²çµ±è¨ˆ ==="
    echo "ç·ãƒ•ã‚¡ã‚¤ãƒ«æ•°: $(ls -1 /mnt/knowledge/EpisodicRAG/Loops/*.txt | wc -l)"
    echo "ç·å®¹é‡: $(du -sh /mnt/knowledge/EpisodicRAG/Loops/ | cut -f1)"
    echo "æœ€æ–°5ä»¶:"
    get_latest_loops | xargs -I {} basename {}
}

# æ¤œç´¢æ©Ÿèƒ½
search_loops() {
    local keyword="$1"
    grep -l "$keyword" /mnt/knowledge/EpisodicRAG/Loops/*.txt | \
        xargs -I {} basename {} | sort -V
}
```

### C++: é«˜é€Ÿæ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <filesystem>
#include <fstream>
#include <algorithm>

class LoopSearchEngine {
private:
    std::vector<std::pair<int, std::string>> loops;
    
public:
    void loadLoops(const std::string& directory) {
        namespace fs = std::filesystem;
        for (const auto& entry : fs::directory_iterator(directory)) {
            if (entry.path().extension() == ".txt") {
                // Loopç•ªå·ã‚’æŠ½å‡º
                std::string filename = entry.path().filename();
                int loopNum = extractLoopNumber(filename);
                loops.push_back({loopNum, entry.path()});
            }
        }
        // ç•ªå·é †ã«ã‚½ãƒ¼ãƒˆ
        std::sort(loops.begin(), loops.end());
    }
    
    std::vector<std::string> search(const std::string& keyword) {
        std::vector<std::string> results;
        for (const auto& [num, path] : loops) {
            if (fileContains(path, keyword)) {
                results.push_back(path);
            }
        }
        return results;
    }
    
private:
    int extractLoopNumber(const std::string& filename);
    bool fileContains(const std::string& path, const std::string& keyword);
};
```

## å®Ÿè£…å¯èƒ½ãªã‚·ã‚¹ãƒ†ãƒ 

ã“ã‚Œã‚‰ã®è¨€èªç’°å¢ƒã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ãªå¤šå±¤çš„ãªå®Ÿè£…ãŒå¯èƒ½ï¼š

1. **Python**: 
   - ãƒ™ã‚¯ãƒˆãƒ«æ¼”ç®—ã€æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«
   - ãƒ‡ãƒ¼ã‚¿åˆ†æã€çµ±è¨ˆå‡¦ç†
   - è‡ªç„¶è¨€èªå‡¦ç†

2. **TypeScript/Node.js**: 
   - å‹å®‰å…¨ãªAPIæ§‹ç¯‰
   - Webã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
   - Officeæ–‡æ›¸ç”Ÿæˆ

3. **C++**: 
   - é«˜é€Ÿãªæ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³
   - ãƒ¡ãƒ¢ãƒªåŠ¹ç‡çš„ãªå‡¦ç†
   - ã‚·ã‚¹ãƒ†ãƒ ãƒ¬ãƒ™ãƒ«ã®æœ€é©åŒ–

4. **Bash**: 
   - ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†è‡ªå‹•åŒ–
   - ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ
   - å®šæœŸå®Ÿè¡Œã‚¿ã‚¹ã‚¯

## ã¾ã¨ã‚

ComputerUseç’°å¢ƒã¯ã€å˜ãªã‚‹Webã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’è¶…ãˆãŸã€å®Œå…¨ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç’°å¢ƒã¨ã—ã¦æ©Ÿèƒ½ã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€EpisodicRAGã®ã‚ˆã†ãªè¤‡é›‘ãªã‚·ã‚¹ãƒ†ãƒ ã‚‚ã€è¤‡æ•°è¨€èªã‚’çµ„ã¿åˆã‚ã›ãŸæœ€é©ãªå½¢ã§å®Ÿè£…å¯èƒ½ã§ã™ã€‚

ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’è·¨ã„ã§ `/mnt/knowledge/` ãŒæ°¸ç¶šåŒ–ã•ã‚Œã‚‹ç‰¹æ€§ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€
äº‹å®Ÿä¸Šã®ã€ŒAIã®å¤–éƒ¨è¨˜æ†¶è£…ç½®ã€ã¨ã—ã¦æ©Ÿèƒ½ã™ã‚‹ã€é©æ–°çš„ãªç’°å¢ƒãŒå®Ÿç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚
